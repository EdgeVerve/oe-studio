<script>
	window.baseUtils = window.baseUtils || {};
	var EV = window.baseUtils;
	baseUtils.clone = function(from, to) {
		if (from === null || typeof from !== 'object') {
			return from;
		}
		if (from.constructor !== Object && from.constructor !== Array) {
			return from;
		}
		if (from.constructor === Date || from.constructor === RegExp || from.constructor === Function ||
			from.constructor === String || from.constructor === Number || from.constructor === Boolean) {
			return new from.constructor(from);
		}
		to = to || new from.constructor();

		for (var name in from) {
			to[name] = typeof to[name] === 'undefined' ? baseUtils.clone(from[name], null) : to[name];
		}

		return to;
	}

	baseUtils.designerData = baseUtils.designerData || {}
	var DesignerBehavior = DesignerBehavior || {}

	DesignerBehavior.HTMLBehavior = {
		attached: function() {
			this.elementInfo = {
				imports: [],
				css: ''
			}
		},
		traverseDom: function(node, cb) {

			var newNode = cb(node);
			if (newNode) {
				node = newNode;
			}
			var children = node.children;
			if (node.nodeName.toLowerCase() === 'template') {
				children = node.content.children;
			}

			if (children) {
				for (var i = 0, len = children.length; i < len; i++) {
					this.traverseDom(children[i], cb);
				}
			}
		},
		traverseDomAll: function(node, cb) {
			var newNode = cb(node);
			if (newNode) {
				node = newNode;
			}

			var children = node.childNodes;
			if (node.nodeName.toLowerCase() === 'template') {
				children = node.content.childNodes;
			}
			if (children) {
				for (var i = 0, len = children.length; i < len; i++) {
					this.traverseDomAll(children[i], cb);
				}
			}
		},
		createNodeFromConfig: function(config) {
			var self = this;
			var ele;
			switch (config.config.type) {
				case 'form-field':
					ele = self.createNodeFromElement(config);
					break;
				case 'element':
				case 'container':
				case 'snippet':
				default:
					if (config.content && config.content.length > 0) {
						ele = self.createNodeFromStr(config.content)
					} else {
						ele = self.createNodeFromName(config.name);
					}
					break;
			}
			this.traverseDom(ele, function(n) {
				var conf = baseUtils.designerData.elementList.find(function(e) {
					return e.tag === n.tagName.toLowerCase();
				})
				if (conf && conf.config) {
					n.setAttribute('oe-id', baseUtils.generateGuid());
					n.setAttribute('oe-ele-type', conf.config.type);
				}
			})
			return ele;
		},
		throughClone: function(node) {
			var temp = document.createElement('template');
			temp.innerHTML = node.outerHTML;
			return temp.content.querySelector(node.nodeName.toLowerCase()).cloneNode(true)
		},
		createNodeFromName: function(nodeType) {
			var parser = new DOMParser();
			var str = '<' + nodeType + '></' + nodeType + '>';
			var doc = parser.parseFromString(str, 'text/html');
			return doc.querySelector(nodeType);
		},
		createNodeFromStr: function(str) {
			var template = document.createElement('template');
			template.innerHTML = str;
			var self = this;
			var ele
			if (template.content.children.length > 1) {
				ele = document.createElement('div');
				ele.classList.add('snippet-container');
				ele.setAttribute('id', 'snippet-container');
				[].forEach.call(template.content.children, function(el) {
					ele.appendChild(self.throughClone(el));
				});
			} else {
				ele = template.content.children[0]
			}
			return ele
		},
		createNodeFromElement: function(config) {
			var self = this;
			var ele = self.createNodeFromName(config.name);
			ele.classList.add('evfield');
			return ele;
		},
		createNodeFromProp: function(config) {
			var self = this;
			var config = element.config;
			var uiType = config.propDef.uitype || (baseUtils.TypeMappings[config.propDef.type] && baseUtils.TypeMappings[config.propDef.type]
				.uiType) || 'oe-input';
			var ele = self.createNodeFromName(uiType);
			ele.classList.add('evfield');
			ele.setAttribute('field-id', config.propName);
			Object.keys(config.propDef).forEach(function(k) {
				if (k !== 'uitype' && k !== 'type' && k !== 'itemtype' && k !== 'evtype') {
					ele.setAttribute(k, '[[_fieldsmeta.' + config.propName + '.' + k + ']]')
				}
			})
			if (!ele.getAttribute('label')) {
				ele.setAttribute('label', config.propName)
			}
			return ele;
		}
	}

	DesignerBehavior.CommonBehavior = {
		polyObjectTopolyJson: function(polyObj) {
			var polyJson = {};
			Object.keys(polyObj).forEach(function(key) {
				var val = polyObj[key];
				if (key === 'properties') {
					polyJson.properties = polyJson.properties || {}
					Object.keys(val).forEach(function(propName) {
						var propVal = val[propName];
						polyJson.properties[propName] = {};
						Object.keys(propVal).forEach(function(propKey) {
							if (propKey === 'type') {
								polyJson.properties[propName].type = propVal[propKey].name;
							} else if (typeof propVal[propKey] === 'function') {
								polyJson.properties[propName][propKey] = propVal[propKey].toString();
							} else {
								polyJson.properties[propName][propKey] = propVal[propKey]
							}
						})
					})
				} else if (key === 'behaviors') {
					polyJson.behaviors = polyJson.behaviors || []
					var EVbehviorList = []
					Object.keys(EV)
						.filter(function() {
							return typeof baseUtils.CaptchaBehavior === 'object'
						})
						.forEach(function(k) {
							EVbehviorList.push({
								'name': 'baseUtils.' + k,
								'value': EV[k]
							})
						});

					val.forEach(function(beh) {
						var ev = EVbehviorList.find(function(b) {
							return (b.value === beh)
						});
						if (ev) {
							polyJson.behaviors.push(ev.name);
						} else if (beh.behaviorName) {
							polyJson.behaviors.push(beh.behaviorName);
						}
					})
				} else {
					if (typeof val === 'function') {
						polyJson.functions = polyJson.functions || {};
						polyJson.functions[key] = val.toString();
					} else {
						polyJson[key] = val
					}
				}
			})
			return polyJson;
		},
		polyJsonTopolyObject: function(polyJson) {
			var polyObj = {};
			Object.keys(polyJson).forEach(function(key) {
				var val = polyJson[key];
				if (key === 'properties') {
					polyObj.properties = polyObj.properties || {}
					Object.keys(val).forEach(function(propName) {
						var propVal = val[propName];
						polyObj.properties[propName] = {};
						Object.keys(propVal).forEach(function(propKey) {
							try {
								polyObj.properties[propName][propKey] = eval(propVal[propKey]);
							} catch (e) {
								polyObj.properties[propName][propKey] = (propVal[propKey]);
							}
						})
					})
				} else if (key === 'behaviors') {
					polyObj.behaviors = polyObj.behaviors || []
					val.forEach(function(beh) {
						try {
							polyObj.behaviors.push(eval(beh))
						} catch (e) {

						}
					})
				} else if (key === 'functions') {
					Object.keys(val).forEach(function(fnName) {
						polyObj[fnName] = new Function('return ' + val[fnName])()
					})
				} else {
					polyObj[key] = val
				}
			})
			return polyObj;
		},
		polyJsonTopolyStr: function(polyJson) {
			var extraAttr = [];
			var polyArr = []
			Object.keys(polyJson).forEach(function(key) {
				var val = polyJson[key];
				switch (key) {
					case 'properties':
						var propStr = '"properties":' + JSON.stringify(val);
						if (JSON.stringify(val).length > 2) {
							polyArr.push(propStr);
						}
						break;
					case 'behaviors':
						var behStr = '"behaviors":[' + val.toString() + ']';
						if (val.toString().length > 0) {
							polyArr.push(behStr);
						}
						break;
					case 'functions':
						var k = JSON.stringify(val);
						k = k.replace(/","/g, ',"').replace(/"function/g, 'function');
						var funcStr = k.slice(1, -2);

						if (funcStr.length > 0) {
							polyArr.push(funcStr);
						}

						break;
					case 'listeners':
						var listenerStr = '"listeners":' + JSON.stringify(val);
						if (JSON.stringify(val).length > 2) {
							polyArr.push(listenerStr);
						}
						break;
					default:
						if (typeof val === 'string') {
							extraAttr.push(('"' + key + '":"' + val + '"'));
						}
				}
			});
			if (extraAttr.join(',\n').length > 0) {
				polyArr.push(extraAttr.join(',\n'))
			}
			var PolyStr = 'MetaPolymer({\n' + polyArr.join(',\n') + '\n})'
			return PolyStr
		}
	}

	DesignerBehavior.ConstantBehavior = {
		attached: function() {

			var relationTypes = [
			{
				value: 'belongsTo',
				label: 'Belongs To',
				icon: 'oe-icons:belongs-to'
			}, {
				value: 'hasOne',
				label: 'Has One',
				icon: 'oe-icons:has-one'
			},{
				value: 'hasMany',
				label: 'Has Many',
				icon: 'oe-icons:has-many'
			},{
				value: 'embedsOne',
				label: 'Embeds One',
				icon: 'oe-icons:embeds-one'
			},{
				value: 'embedsMany',
				label: 'Embeds Many',
				icon: 'oe-icons:embeds-many'
			}];
/*
		Polymorphic currently not created from designer
			{
				value: 'polymorphic',
				label: 'Polymorphic',
				icon: 'oe-icons:polymorpic'
			}
*/

			var readProperty = [{
				value: 'exists',
				label: 'Exists'
			}, {
				value: 'find',
				label: 'Find'
			}, {
				value: 'findById',
				label: 'Find By Id'
			}, {
				value: 'findOne',
				label: 'Find One'
			}, {
				value: 'count',
				label: 'Count'
			}]

			var writeProperty = [{
				value: 'create',
				label: 'Create'
			}, {
				value: 'upsert',
				label: 'Upsert'
			}, {
				value: 'destroyById',
				label: 'Delete By Id'
			}]

			var aclPropertyList = {
				write: writeProperty,
				read: readProperty,
				all: writeProperty.concat(readProperty)
			}
			var aclAccessType = [{
				value: '*',
				label: 'All'
			}, {
				value: 'WRITE',
				label: 'WRITE'
			}, {
				value: 'READ',
				label: 'READ'
			}, {
				value: 'EXECUTE',
				label: 'EXECUTE'
			}]

			var dropdownList = {
				relationTypes: relationTypes,
				acl: {
					property: aclPropertyList,
					access: aclAccessType
				}
			}

			var regexObj = {
				camelCase: "^([A-Z][a-z0-9]+)+",
				dashCase: "^([a-zA-Z0-9]+)((-[a-zA-Z0-9]+)+)$",
				polymerName: "^([a-z]+)((-[a-z0-9]+)+)$"
			}

			this.set('dropdownConst', dropdownList);
			this.set('regexpConst', regexObj);
		}
	}

</script>
